import runtime;
import ds/tree;
import lingo/pegcode/driver;

export {
    Prog : (d: [Decl], expr: Unit);

    Decl : (kv: [Pair<Var,Unit>]);
    Unit ::= Int, Sub, Add, Div, Mult, Negative, Var;

    Add : (v1: Unit, v2: Unit);
    Sub : (v1: Unit, v2: Unit);
    Mult : (v1: Unit, v2 : Unit);
    Div : (v1: Unit, v2 : Unit);
    Negative : (v: Unit);
    Int : (val: int);
    Var : (val: string);

    buildSub(xs: [flow]) -> Sub;
    buildDiv(xs: [flow]) -> Div;
    buildDeclMap(d: [Decl]) -> Tree<string, Unit>;

    s2infixAst(s : string) -> Prog;
    infixAst2s(ast : Unit) -> string;

    Rational: (num: int, denom: int);
    addRational(r1: Rational, r2: Rational) -> Rational;
    subRational(r1: Rational, r2: Rational) -> Rational;
    multRational(r1: Rational, r2: Rational) -> Rational;
    divRational(r1: Rational, r2: Rational) -> Rational;
    negateRational(r: Rational) -> Rational;
    simplifyRational(r: Rational) -> Rational;
    validateRational(r: Rational) -> Maybe<Rational>;
    i2r(v: int) -> Rational;
    r2unit(r: Rational) -> Unit;

    ast2mr(ast: Unit, map: Tree<string, Unit>) -> Maybe<Rational>;

    buildDerativeTree(ast: Unit, var: string) -> Unit;
    simplifyDerative(ast: Unit) -> Unit;
}

buildSub(xs) {
    fold(xs[1], xs[0], \acc, x -> Sub(acc, x))
}

buildDiv(xs) {
    fold(xs[1], xs[0], \acc, x -> Div(acc, x))
}


infixLingo : ref Maybe<[PegOp]> = ref None();

s2infixAst(s)-> Prog {
    parsic(
        onlyOnce(
            infixLingo, \ -> {
		compilePegGrammar("#include infix.lingo");
	    }),
        s,
        pegActions(
            [
                Pair("buildSub", buildSub),
                Pair("buildDiv", buildDiv)
            ]
            )
        )
}

buildDeclMap(d) {
    map: Tree<string, Unit> = makeTree();
    if (length(d) == 0)
        map
    else {
        fold(d[0].kv, map, \acc, e -> setTree(acc, e.first.val, e.second))
    }
}

_ast2s(ast: Unit, par)-> string {
    switch (ast) {
        Int(val): i2s(val);
        Var(v): v;
        Negative(v): "-" + _ast2s(v, true);
        Add(v1,v2): {
            arr = infixAst2s(v1)+ "+"+ infixAst2s(v2);
            if(par) 
                concatStrings(["(", arr, ")"])
            else 
                arr;
        }
        Sub(v1,v2): {
            arr = infixAst2s(v1)+ "-"+ infixAst2s(v2);
            if(par) 
                concatStrings(["(", arr, ")"])
            else 
                arr;
        }
        Mult(v1,v2): concatStrings([_ast2s(v1,true), "*", _ast2s(v2,true)]);
        Div(v1,v2): concatStrings([_ast2s(v1,true), "/", _ast2s(v2,true)]);       
    }
}

infixAst2s(ast) {
    _ast2s(ast, false)
}

addRational(r1,r2) {
    simplifyRational(Rational(r1.num * r2.denom + r2.num * r1.denom, r1.denom * r2.denom))
}

subRational(r1,r2) {
    simplifyRational(Rational(r1.num * r2.denom - r2.num * r1.denom, r1.denom * r2.denom))
}

multRational(r1,r2) {
    simplifyRational(Rational(r1.num * r2.num, r1.denom * r2.denom))
}

divRational(r1,r2) {
    simplifyRational(Rational(r1.num * r2.denom, r1.denom * r2.num))
}

simplifyRational(r) {
    gcd = \a:int, b:int -> if (b == 0) a else gcd(b, a % b);
    div = gcd(r.num, r.denom);
    if (div != 0) {
        Rational(r.num / div, r.denom / div)
    } else r
}

validateRational(r) {
    if (r.denom == 0) {
        None()
    } else Some(r)
}

i2r(v) {
    Rational(v,1)
}

r2unit(r) {
    if (r.num == 0) {
        Int(0)
    } else {
        if (r.denom == 1) {
            Int(r.num)
        } else {
            Div(Int(r.num), Int(r.denom))
        }
    }
}

negateRational(r) {
    Rational(-r.num, r.denom)
}

ast2mr(ast, map) {
    maybeBind(_ast2mr(ast,map),validateRational)
}

_ast2mr(ast, map){
    _self = \e -> maybeBind(_ast2mr(e,map), validateRational);
    _map = \fn,v1,v2 -> maybeMap2(fn)(_self(v1), _self(v2));
    switch(ast) {
        Int(v): Some(i2r(v));
        Var(v): {
            val = lookupTree(map, v);
            maybeBind(val, _self)
        }
        Negative(v): maybeMap(_self(v), negateRational);
        Add(v1,v2): _map(addRational,v1,v2);
        Sub(v1,v2): _map(subRational,v1,v2);
        Mult(v1,v2): _map(multRational,v1,v2);
        Div(v1,v2): _map(divRational,v1,v2);
    }
}

isInt(unit: Unit) -> Maybe<Int> {
    switch(unit) {
        Int(v): Some(Int(v));
        Var(x): None();
        Add(a,b): None();
        Sub(a,b): None();
        Mult(a,b): None();
        Div(a,b): None();
        Negative(v): None();
    }
}

isNegative(unit: Unit) -> Maybe<Unit> {
    switch(unit) {
        Int(v): None();
        Var(x): None();
        Add(a,b): None();
        Sub(a,b): None();
        Mult(a,b): None();
        Div(a,b): None();
        Negative(v): Some(v);
    }
}

isZero(v: Int) {
    v == Int(0)
}

simplifyAdd(a: Unit, b: Unit) {
    v1 = Pair(eitherMap(isInt(a), isZero, false), b);
    v2 = Pair(eitherMap(isInt(b), isZero, false), a);
    if (v1.first && v2.first) {
        Int(0)
    } else {
        if (v1.first) {
            v1.second
        } else {
            if (v2.first) {
                v2.second
            } else {
                Add(a, b)
            }
        }
    } 
}

simplifySub(a: Unit, b: Unit) {
    v1 = Pair(eitherMap(isInt(a), isZero, false), b);
    v2 = Pair(eitherMap(isInt(b), isZero, false), a);
    if (v1.first && v2.first) {
        Int(0)
    } else {
        if (v1.first) {
            Negative(v1.second)
        } else {
            if (v2.first) {
                v2.second
            } else {
                Sub(a, b)
            }
        }
    }
}

simplifyMult(a: Unit, b: Unit) {
    v1 = eitherMap(isInt(a), isZero, false);
    v2 = eitherMap(isInt(b), isZero, false);
    if (v1 || v2) {
        Int(0)
    } else {
        vv1 = Pair(eitherMap(isInt(a), \v->v==Int(1), false), b);
        vv2 = Pair(eitherMap(isInt(b), \v->v==Int(1), false), a);
        if (vv1.first && vv2.first) {
            Int(1)
        } else {
            if (vv1.first) {
                vv1.second
            } else {
                if (vv2.first) {
                    vv2.second
                } else {
                    Mult(a, b)
                }
            }
        }                 
    }
}

simplifyDiv(a: Unit, b: Unit) {
    v1 = eitherMap(isInt(a), isZero, false);
    v2 = eitherMap(isInt(b), isZero, false);
    if (v1 && !v2) {
        Int(0)
    } else {
        vv2 = Pair(eitherMap(isInt(b), \v->v==Int(1), false), a);
        if (vv2.first) {
            vv2.second
        } else {
            if (a == b) {
                Int(1)
            } else {
                Div(a,b)
            }
        }                 
    }     
}

simplifyNegative(v: Unit) {
    v1 = Pair(eitherMap(isInt(v), isZero, false), v);
    if (v1.first) {
        Int(0)
    } else {
        eitherMap(isNegative(v), idfn, Negative(v))
    }
}

simplifyDerative(ast: Unit) -> Unit{
    switch(ast) {
        Int(v): Int(v);
        Var(x): Var(x);
        Add(a,b): simplifyAdd(simplifyDerative(a),simplifyDerative(b));
        Sub(a,b): simplifySub(simplifyDerative(a),simplifyDerative(b));
        Mult(a,b): simplifyMult(simplifyDerative(a),simplifyDerative(b));
        Div(a,b): simplifyDiv(simplifyDerative(a),simplifyDerative(b));
        Negative(v): simplifyNegative(simplifyDerative(v));
    }    
}

buildDerativeTree(ast, var) {
    switch (ast) {
        Int(v): Int(0);
        Var(v): if (v == var) Int(1) else Int(0)
        Negative(v): Negative(buildDerativeTree(v,var));
        Add(v1,v2): Add(buildDerativeTree(v1,var),buildDerativeTree(v2,var));
        Sub(v1,v2): Sub(buildDerativeTree(v1,var),buildDerativeTree(v2,var));
        Mult(v1,v2): Add(
            Mult(buildDerativeTree(v1,var),v2),
            Mult(v1,buildDerativeTree(v2,var))
        );
        Div(v1,v2): Div (
            Sub(Mult(buildDerativeTree(v1,var),v2), Mult(v1, buildDerativeTree(v2,var))),
            Mult(v2,v2)
        )
    }
}

//map of var:pow
PTerm : (t: Tree<string, int>);
Polynomial : (e : Tree<PTerm, int>);
RationalPoly : (p1 : Polynomial, p2 : Polynomial);

treeMergeFn(t1: Tree<?, ??>, t2: Tree<?, ??>, fn: (??, ??) -> ??) -> Tree<?,??> {
    mergeTreeCustom(t1,t2,\k,v1,v2-> fn(v1,v2))
}

buildPolynomialFn(p1: Polynomial, p2: Polynomial, fn: (int, int) -> int) {
    Polynomial(treeMergeFn(p1.e, p2.e, fn))
}

negatePolynomial(t: Polynomial) {
    Polynomial(
        mapTree(
            t.e,
            \v -> -v
        )
    )
}

multTerm(t1: PTerm, t2: PTerm) {
    PTerm(treeMergeFn(t1.t, t2.t, \a,b -> a + b))
}

addPolynmial(p1: Polynomial, p2: Polynomial) {
    buildPolynomialFn(p1, p2,\a, b -> a + b)
}

subPolynomial(p1: Polynomial, p2: Polynomial) {
    buildPolynomialFn(p1, p2, \a, b -> a - b)
}

multPolynomial(p1: Polynomial, p2: Polynomial) {
    Polynomial(
        foldTree(
            p1.e,
            makeTree(),
            \k,v,acc -> {
                mergeTreeCustom(
                    acc,
                    foldTree(
                        p2.e,
                        makeTree(),
                        \ki, vi, acci -> {
                            setTree(acci, multTerm(k, ki), v * vi)
                        }
                    ),
                    \kj, v1, v2 -> v1 + v2
                )
            }
        )
    )
}

buildConstantTerm() {
    PTerm(makeTree())
}

buildTerm1(k: string, v: int) {
    PTerm(makeTree1(k, v))
}

buildPoly1(t: PTerm, v: int) {
    Polynomial(makeTree1(t, v))
}

buildConstantPoly(v: int) {
    buildPoly1(buildConstantTerm(), v)
}

ast2rp(e: Unit) -> RationalPoly {
    switch(e) {
        Int(v): {
            RationalPoly(
                buildConstantPoly(v),
                buildConstantPoly(1)
            )
        }
        Var(x): {
            RationalPoly(
                buildPoly1(buildTerm1(x, 1), 1),
                buildConstantPoly(1)
            )
        }
        Negative(v): {
            r = ast2rp(v);
            RationalPoly(
                negatePolynomial(r.p1),
                r.p2
            )         
        }
        Add(v1,v2): {
            l = ast2rp(v1);
            r = ast2rp(v2);
            RationalPoly(
                addPolynmial(
                    multPolynomial(l.p1, r.p2),
                    multPolynomial(r.p1, l.p2)
                ),
                multPolynomial(l.p2, r.p2)
            )
        }
        Sub(v1,v2): {
            l = ast2rp(v1);
            r = ast2rp(v2);
            RationalPoly(
                subPolynomial(
                    multPolynomial(l.p1, r.p2),
                    multPolynomial(r.p1, l.p2)
                ),
                multPolynomial(l.p2, r.p2)
            )
        }
        Mult(v1,v2): {
            l = ast2rp(v1);
            r = ast2rp(v2);
            RationalPoly(
                multPolynomial(l.p1,r.p1),
                multPolynomial(l.p2,r.p2)
            )
        }
        Div(v1,v2): {
            l = ast2rp(v1);
            r = ast2rp(v2);
            RationalPoly(
                multPolynomial(l.p1,r.p2),
                multPolynomial(l.p2,r.p1)
            )           
        }
    }
}

t2s(t: PTerm) {
    foldTree(
        t.t,
        "",
        \k, v, acc -> {
            acc + k + "^" + i2s(v)
        }
    )
}

p2s(p: Polynomial) {
    rtrim2(foldTree(
        p.e,
        "",
        \k,v,acc -> {
            acc + i2s(v) + t2s(k) + " + "
        }
    ), "+ ")
}

rp2s(rp: RationalPoly) {
    num = p2s(rp.p1);
    denom = p2s(rp.p2);
    divstr = strRepeat("-", max(strlen(num), strlen(denom)));
    num + "\n" + divstr + "\n" + denom
}

main() {
    prog = s2infixAst("(-425*x*x*y + 35*y*x*x)/3*x+4*z/5*y");
    ast = prog.expr;
    r = ast2rp(ast);
    println(rp2s(r));
    quit(0);
}